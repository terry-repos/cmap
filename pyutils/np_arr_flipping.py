import sysimport numpy as npsys.path.append('..')def make_nans_zero_ATs_one(tinArr):    tOutArr = np.copy(tinArr)    tOutArr[np.where(tinArr>0)] = 1    tOutArr[np.where(np.isnan(tinArr))] = 0    return tOutArrdef make_nans_zero(inArr):    outArr = np.copy(inArr)    outArr[np.where(np.isnan(inArr))] = 0    return outArrdef make_nans_ones(inArr):    outArr = np.copy(inArr)        outArr[np.where(np.isnan(inArr))] = 1    return outArr  def make_nans_to(zinArr, val=0):    outArr = np.copy(zinArr)        outArr[np.where(np.isnan(zinArr))] = val    return outArr          def make_zeros_nans(inArr):    outArr = np.copy(inArr)            outArr[np.where(inArr==0)] = np.nan    return outArrdef make_ones_nans(inArr):    outArr = np.copy(inArr)            outArr[np.where(inArr==1)] = np.nan    return outArr   def make_non_nans_one(inArr):    outArr = np.copy(inArr)            outArr[get_non_nan_coords(inArr)] = 1    return outArr   def get_non_nans(inArr):    outArr = np.copy(inArr)    outArr = outArr[get_non_nan_coords(inArr)]    return outArrdef get_non_nan_coords(zinArr):    znonNaNs = make_nans_zero_ATs_one(zinArr)    znonNanCoords = np.where(znonNaNs==1)    return znonNanCoords   def get_nan_coords(xinArr):    zNanCoords = np.where(np.isnan(xinArr))    return zNanCoords# def get_non_neg_ones( inArr ):#     zNanCoords = np.where( ~inArr == -1 ) #     return zNanCoords    def invert_zeros_ones(inMat):    tempMat = np.copy(inMat)    tempMat[np.where(inMat==0)] = 1    tempMat[np.where(inMat==1)] = 0    return tempMatdef get_non_x_items(inPutArr, valOfInterest=-1):    tempArr = np.copy(inPutArr)    # nNonXItems = tempArr[ np.where(inPutArr==valOfInterest) ].ravel().shape[0]    nNonXItems = tempArr[np.where((inPutArr < valOfInterest) | (inPutArr > valOfInterest)) ]    return nNonXItemsdef get_num_non_x_items(inPutArr, valOfInterest=-1):    tempArr = np.copy(inPutArr)    # nNonXItems = tempArr[ np.where(inPutArr==valOfInterest) ].ravel().shape[0]    nNonXItems = tempArr[np.where((inPutArr < valOfInterest) | (inPutArr > valOfInterest)) ].ravel().shape[0]    return nNonXItems# def order_row_indices_by_asc_order_of_non_x_items(indArr,valOfInterest=-1):#     tempArr = np.copy(inPutArr)#     # nNonXItems = tempArr[ np.where(inPutArr==valOfInterest) ].ravel().shape[0]#     nNonXItems = tempArr[ np.where((indArr < valOfInterest) | (inPutArr > valOfInterest)) ]#     chansWithMostEvents = Counter( nNonXItems[0] ).most_common()#     print("chansWithMostEvents: ", chansWithMostEvents)#     return nNonXItems    ## =========== numpy union intersection ========def replace_2d_arr_with_union_of(intersection12, union1, union2, replaceArr):    tmpArr = np.copy(union1)    union1[get_non_nan_coords(intersection12)] = np.nan    tmpArr[:,:] = union1+union2    return tmpArrdef replace_2d_arr_with_intersection_of(intersect1, intersection2, replaceArr):    tmpArr = np.copy(replaceArr)    tmpArr[:,:] = np.nan    tmpArr[np.where(intersect1==intersection2)] = replaceArr[np.where(intersect1==intersection2)]        return tmpArrdef replace_2d_arr_with_difference_of(this1, minusThis1):    tmpArr = np.copy(this1)    tmpArr[:,:] = np.nan    tmpArr[np.where(this1!=minusThis1)] = this1[np.where(get_nthis1!=minusThis1)]    return np.copy(tmpArr)def union_of(intersection12, union1, union2):    tmpArr = np.copy(union1)    union1[get_non_nan_coords(intersection12)] = np.nan    tmpArr[:,:] = union1 + union2    return tmpArrdef intersection_of(intersect1, intersect2):    tmpArr = np.copy(intersect1)    tmpArr[:,:] = np.nan    tmpArr[np.where(intersect1==intersect2)] = intersect1[np.where(intersect1==intersect2)]    return tmpArr        