# ======= function to speed up animationdef _blit_draw(self, artists, bg_cache):# Handles blitted drawing, which renders only the artists given instead# of the entire figure.    updated_ax = []    for a in artists:    # If we haven't cached the background for this axes object, do    # so now. This might not always be reliable, but it's an attempt    # to automate the process.        if a.axes not in bg_cache:        # bg_cache[a.axes] = a.figure.canvas.copy_from_bbox(a.axes.bbox)        # change here            bg_cache[a.axes] = a.figure.canvas.copy_from_bbox(a.axes.figure.bbox)            a.axes.draw_artist(a)            updated_ax.append(a.axes)    # After rendering all the needed artists, blit each axes individually.    for ax in set(updated_ax):    # and here    # ax.figure.canvas.blit(ax.bbox)        ax.figure.canvas.blit(ax.figure.bbox)        # MONKEY PATCH!!        matplotlib.animation.Animation._blit_draw = _blit_draw  #=== END MISC HELPER FUNCTIONS## ====== OUTPUT FUNCTIONS such as PLOTTING and ANIMATION, using MATPLOTLIBdef make_animation(inputWavesFileArg, outputFilePath, arrToAnimate, minval, maxval, rangeOfStep, fps_, dpi, paddingVal):    print("pooling together the animation array, making text")    print("arrToAnimate Shape ", str(arrToAnimate.shape))    global resXi    try:        # Takes the stuff from the figure caption        titleStart = 9 + inputWavesFileArg.index('__Figure')        titleEnd = inputWavesFileArg.index('.txt')        # titleStr = "Figure " + inputWavesFileArg[titleStart:titleEnd]        titleStr = titleStr.replace("_","")        titleStr = ""    except Exception as e:        titleStr = ""    nFrames = arrToAnimate.shape[0]    font_size = (int)(round((resXi**2)*0.5))    ## Text spacing values    proxDistW = 1.2*paddingVal     centerW = arrToAnimate.shape[2]*.5    proxH = arrToAnimate.shape[1] - paddingVal + (int)(round(paddingVal*.23))    distH = arrToAnimate.shape[1] - (arrToAnimate.shape[1]-paddingVal) - (int)(round(paddingVal*.38))    timeH = proxH + (int)(round(paddingVal * .40))    timeH = arrToAnimate.shape[1] - (paddingVal - round((resXi**2) * 0.3))    # Set up formatting for the movie files    Writer = animation.writers['ffmpeg']    writer = Writer(fps=fps_, metadata=dict(artist='Me'), bitrate=4800)        figDims = (arrToAnimate.shape[2]/100),(arrToAnimate.shape[1]/100)    fig = plt.figure(figsize = figDims, frameon=False)    fig.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=None, hspace=None)    ax = plt.axes()    # # remove axes    plt.yticks([])    plt.xticks([])       print("Attempting to render animation")         # TEXT    timeText = ax.text(proxDistW, timeH,'', size=font_size, transform=None )    figureText = ax.text(centerW, timeH, titleStr,transform=None )    # proxText = ax.text(proxDistW,proxH,'Proximal',transform=None)    # distText = ax.text(proxDistW,distH,'Distal',transform=None)    realTimeAnimationLength = maxval - minval    timeMultiplier = round((realTimeAnimationLength / nFrames * fps_),1)    im = plt.imshow(arrToAnimate[0,:,:,:], interpolation='None', animated=True, aspect='auto')    with writer.saving(fig, outputFilePath, 100):        for counter in range(0,nFrames):            # print(str(np.nanmin(arrToAnimate[counter,:,:,0])) + "-" + str(np.nanmax(arrToAnimate[counter,:,:,0]))                timeValue = counter*rangeOfStep #+minval (+minval will start counter from file time)            timeValueAndXstr = str(round(timeValue,3)).zfill(2) + "s" # x" + str(timeMultiplier)             timeText.set_text(timeValueAndXstr)            im.set_array(arrToAnimate[counter,:,:,:])            writer.grab_frame()    print("Finished processing waves")def merge_waves_across_time(waves, animatedWaves, timeIncr):    print("waves.shape: ", waves[0].shape)    print("len waves: ", len(waves))    flattenedWaves = np.hstack(waves)    #Get time range across all waves    completeTimeRange, completeMinTa, completeMax = create_time_range(flattenedWaves, timeIncr, addElecLightUpTime = False)    print("Time range across all waves: ", str(completeTimeRange.shape))    twaves = np.zeros(5)    combinedWaves = np.zeros(shape=(completeTimeRange.shape[0], animatedWaves[0].shape[1], animatedWaves[0].shape[2]), dtype = float)    for wave, animatedWave in zip(waves, animatedWaves):        minNext = np.nanmin(wave)-timeIncr        actualNext =  np.nanmin(wave)        beginIntersect = np.where((completeTimeRange >= minNext) & (completeTimeRange <= actualNext))[0]        beginIntersect = beginIntersect[0]         endIntersect = beginIntersect + animatedWave.shape[0]         if (endIntersect > completeTimeRange.shape[0]):            endIntersect = completeTimeRange.shape[0]        animatedWaveEndIntersect = endIntersect - beginIntersect        combinedWaves[beginIntersect:endIntersect,:,:] = np.add(combinedWaves[beginIntersect:endIntersect,:,:], animatedWave[0:animatedWaveEndIntersect,:,:])    return completeTimeRange, completeMinTa, completeMax, combinedWavesdef add_time_dimension___make_trailing_edge(ATwave, timeIncrement,sigmaVal3d):    ## calc time range of array    timeRange, minVal, maxVal = create_time_range(ATwave, timeIncrement)    # ## convert array to frames for animating    animatedWave, trailingEdgeMask = convert_arr_to_frames(ATwave, timeRange, timeIncrement)    ## make gaussian    animatedWave = make_gaussian_3d(animatedWave, trailingEdgeMask, sigmaVal3d)     return animatedWave     def merge_waves___overlay_CBs___beautify_prior_to_animating(inputWavesFile, inputWaves, trailingEdgeTimeWaves, timeIncr, staticFigureFilename=None, addBorderToWave=True, overlayElecs=True, overlayCB=None, CB=None, cbGray=None):       completeTimeRange, globalMinTa, globalMaxTa, beautifiedAnimatedWaves = merge_waves_across_time(inputWaves, trailingEdgeTimeWaves, timeIncr)    #Normalise the interpolated values for the plotting    beautifiedAnimatedWaves = (1-normalise_between((beautifiedAnimatedWaves), [0.0, 1.0]))    beautifiedAnimatedWaves, animPaddingVal = overlay_visualise_animation(inputWaves, beautifiedAnimatedWaves, completeTimeRange,  addBorderToWave, overlayElecs, overlayCB, CB,  cbGray)                  # To insert a static figure, such as a stomach in the correspodnding location.     # *** Note filename of figure NEEDS to match that of the txt file.    if insertStaticFigureAsCompanion:        if not staticFigureFilename:            staticFigureFilename = inputWavesFile.replace('.txt','.png')                # Only do image manipulation if image exists        if os.path.isfile(staticFigureFilename):            beautifiedAnimatedWaves = insert_static_figure(beautifiedAnimatedWaves, paddingVal, staticFigureFilename)    return beautifiedAnimatedWaves, globalMinTa, globalMaxTa, animPaddingVal    