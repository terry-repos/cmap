## ============ GRAPHICAL OVERLAY FUNCTIONS## ============ overlay visualise such as borders, and electrodesdef resize_image_with_scipy(upsampledRawWave, newShape):    newArr = np.full(shape=newShape, fill_value=np.nan, dtype="float")    try:        upsampledRawWave[np.isnan(upsampledRawWave)] = 0    except Exception as e:        print(e)        return newArr    ratio = upsampledRawWave.shape[0] / newShape[0]    resizedImage = img_as_float(misc.imresize(upsampledRawWave, newShape, interp="nearest"))    resizedImage[np.where(resizedImage==0)] = np.nan    return resizedImagedef twoDarr_to_cmap_rgb(nonRGBarr):    global newCmap    cmap = plt.cm.get_cmap(newCmap)    rgbArr = cmap(nonRGBarr)    # Keep nan's nans so they plot, white for e.g.    rgbArr[np.isnan(nonRGBarr)] = np.nan    # rgbArr[np.where(nonRGBarr==1)] = np.nan #keep nans and add nans for 1        return rgbArrdef animation_arr_to_rgb(inArr, makeRed):    newArr = np.full(shape=(inArr.shape[0], inArr.shape[1], inArr.shape[2], 4), fill_value=1.0, dtype="float32")    if makeRed:        newArr[:,:,:,0] = 1        newArr[:,:,:,1] = inArr        newArr[:,:,:,2] = inArr        newArr[:,:,:,3] = 1    else: # Make blue        newArr[:,:,:,0] = inArr        newArr[:,:,:,1] = inArr        newArr[:,:,:,2] = 1        newArr[:,:,:,3] = 1    newArr[np.isnan(newArr)] = 0    return newArr    def insert_static_figure(anInArr, pv, fileNameAndPath=None):       companionFig = ndimage.imread(fileNameAndPath)    ratio = ((anInArr.shape[1] - pv * 2) / companionFig.shape[0]) * backgroundImageScalingMultiplier #resize by height of wave, and make slightly smaller    print("Resizing image and converting to float values")    resizedFig = img_as_float(misc.imresize(companionFig, ratio, interp="bicubic"))    newArrWidth = (anInArr.shape[2] + resizedFig.shape[1] + pv)    arrayWithCompanionFig = np.full(shape=(anInArr.shape[0], anInArr.shape[1], newArrWidth, 4), fill_value=1.0, dtype="float32")    arrayWithCompanionFig[:, : , 0 : anInArr.shape[2], :] = anInArr    startC = (anInArr.shape[2])    endC = startC + (resizedFig.shape[1])    startR = (int(round(anInArr.shape[1] - resizedFig.shape[0] ) / 2 ))    endR = startR + (resizedFig.shape[0])    #add background stomach to every frames    print("Adding background to every frame while giving space for wave width and padding")    arrayWithCompanionFig[:, startR : endR, startC : endC, 0:3] = resizedFig    return arrayWithCompanionFig    arrWithBorder[0, 0:right, 0:2] = 0 #top line    arrWithBorder[0, 0:right, 3] = 1 #top line    arrWithBorder[bottom, 0:right, 0:2] = 0 #bot line    arrWithBorder[bottom, 0:right, 3] = 1 #bot line    arrWithBorder[0:bottom, 0, 0:2] = 0 #left line    arrWithBorder[0:bottom, 0, 3] = 1 #left line    arrWithBorder[0:bottom, right, 0:2] = 0 #right line        arrWithBorder[0:bottom, right, 3] = 1 #right line        return arrWithBorder    def add_border_to_rgb(arrWithoutBorder,  theColor, size):    print("arrWithoutBorder len",len(arrWithoutBorder.shape))    print("print shape",arrWithoutBorder.shape)    if len(arrWithoutBorder.shape)==2:        tempArrWithoutBorder = np.zeros(shape=(arrWithoutBorder.shape[0],arrWithoutBorder.shape[1],4), dtype="float")        tempArrWithoutBorder[:,:,0] = arrWithoutBorder        print("print NEW shape",arrWithoutBorder.shape)    arrWithBorder = pad_rgb_2d_edges(arrWithoutBorder, size)    bottom, right, rgbSize = arrWithBorder.shape       arrWithBorder[0:size, 0:right, 0:2] = 0 #top line    arrWithBorder[bottom:(bottom-size), 0:right, 0:2] = 0 #bot line    arrWithBorder[0:bottom, 0:size, 0:2] = 0 #left line    arrWithBorder[0:bottom, (right-size):right, 0:2] = 0 #right line         arrWithBorder[0:size, 0:right, 3] = 1 #top line    arrWithBorder[bottom:(bottom-size), 0:right, 3] = 1 #bot line    arrWithBorder[0:bottom, 0:size, 3] = 1 #left line    arrWithBorder[0:bottom, (right-size):right, 3] = 1 #right line     if theColor=='red':        arrWithBorder[0:size, 0:right, 0] = 1 #top line        arrWithBorder[bottom:(bottom-size), 0:right, 0] = 1 #bot line        arrWithBorder[0:bottom, 0:size, 0] = 1 #left line        arrWithBorder[0:bottom, (right-size):right, 0] = 1 #right line        return arrWithBorderdef add_border_to_2d(arrToAddBorder, rgbcolor, size):    bottom = arrToAddBorder.shape[0]    right = arrToAddBorder.shape[1]    arrWithBorder = pad_2d_edges(arrToAddBorder, size)    return arrWithBorder  def add_border_to_animation(arrWithoutBorder):    print("Add border to wave model to animation")    global resXi    if resXi >= 7:        bWidth = 2    else:        bWidth = 1    arrWithBorder, pv = pad_3d_edges(arrWithoutBorder, bWidth)    bottom = arrWithBorder.shape[1]-1    right = arrWithBorder.shape[2]-1    arrWithBorder[:, 0, 0:right, 0] = 0 #top line    arrWithBorder[:, bottom, 0:right, 0] = 0 #bot line    arrWithBorder[:, 0:bottom, 0, 0] = 0 #left line    arrWithBorder[:, 0:bottom, right, 0] = 0 #right line    arrWithBorder[:, 0, 0:right, 1] = 0 #top line    arrWithBorder[:, bottom, 0:right, 1] = 0 #bot line    arrWithBorder[:, 0:bottom, 0, 1] = 0 #left line    arrWithBorder[:, 0:bottom, right, 1] = 0 #right line    arrWithBorder[:, 0, 0:right, 2] = 0 #top line    arrWithBorder[:, bottom, 0:right, 2] = 0 #bot line    arrWithBorder[:, 0:bottom, 0, 2] = 0 #left line    arrWithBorder[:, 0:bottom, right, 2] = 0 #right line    arrWithBorder[:, 0, 0:right, 3] = 1 #top line    arrWithBorder[:, bottom, 0:right, 3] = 1 #bot line    arrWithBorder[:, 0:bottom, 0, 3] = 1 #left line    arrWithBorder[:, 0:bottom, right, 3] = 1 #right line      return arrWithBorderdef overlay_CB_2d(rgbATs, CB, cbGray):    CBcoords = np.where(CB==True)    # print(len(CB)    for r,c in zip(CBcoords[0], CBcoords[1]):        rgbATs[r,c,0:3] = cbGray         rgbATs[r,c,3] = 1    return rgbATsdef overlay_directions(inArr, arrowImg):    directionsCoords = get_non_nan_coords(arrowImg[:,:,1])    if inArr.shape == arrowImg.shape:        for rgb in range(0,3):            print(rgb)            for r,c in zip(directionsCoords[0], directionsCoords[1]):                inArr[r,c,rgb] = arrowImg[r,c,rgb]                 inArr[r,c,3] = 1    return inArr    ## Def arraydef overlay_CB_animation(originalInputList, inArr, cbList, timeIncr, completeTimeRange, cbGray):    newArr = inArr      global globalMinTa    global globalMaxTa    prfrE = 0 #previous end     nOriginalInputArr = len(originalInputList)    origI = 0    for originalInputArr, CBii in zip(originalInputList, cbList):        origI += 1        actualCB = CBii.pop().pop()        minAT = np.nanmin(originalInputArr)        maxAT = np.nanmax(originalInputArr)        frS, frE = get_frame_intersect_by_timeRange((minAT-(timeIncr), maxAT+(timeIncr)), completeTimeRange)        for timePoint in range(frS, frE):            inArr[timePoint,:,:,:] = overlay_CB_2d(inArr[timePoint,:,:,:], actualCB, cbGray)    return inArr    def make_border_4d(in4d, startF, endF, ir1, ir2, ic1, ic2, bColor="black"):    if bColor =="black":        cV = 0        mV = 0        yV = 0        kV = 1    elif bColor =="white":        cV = 1        mV = 1        yV = 1        kV = 0    elif bColor =="darkOrange":        cV = 0.99        mV = 0.6        yV = 0        kV = 0.99            in4d[startF : endF, ir1, ic1 : ic2, 0] = cV    in4d[startF : endF, ir1, ic1 : ic2, 1] = mV                  in4d[startF : endF, ir1, ic1 : ic2, 2] = yV    in4d[startF : endF, ir1, ic1 : ic2, 3] = kV    # BOTTOM OUTLINE    in4d[startF : endF, ir2, ic1 : ic2, 0] = cV    in4d[startF : endF, ir2, ic1 : ic2, 1] = mV                 in4d[startF : endF, ir2, ic1 : ic2, 2] = yV    in4d[startF : endF, ir2, ic1 : ic2, 3] = kV    # LEFT OUTLINE    in4d[startF : endF, ir1 : ir2, ic1, 0] = cV    in4d[startF : endF, ir1 : ir2, ic1, 1] = mV                   in4d[startF : endF, ir1 : ir2, ic1, 2] = yV    in4d[startF : endF, ir1 : ir2, ic1, 3] = kV    # RIGHT OUTLINE    in4d[startF : endF, ir1 : (ir2+1), ic2, 0] = cV    in4d[startF : endF, ir1 : (ir2+1), ic2, 1] = mV                  in4d[startF : endF, ir1 : (ir2+1), ic2, 2] = yV    in4d[startF : endF, ir1 : (ir2+1), ic2, 3] = kV    return in4d## Def arraydef overlay_elecs_on_animation(originalInputList, inArr, timeIncr, completeTimeRange):    global resXi    newArr = inArr      global globalMinTa    global globalMaxTa    global electrodeLightUpTime    prfrE = 0 #previous end     nOriginalInputArr = len(originalInputList)    origI = 0    for originalInputArr in originalInputList:        origI += 1        print("origI: ",origI)        minAT = np.nanmin(originalInputArr)        maxAT = np.nanmax(originalInputArr)        if resXi==7:            eSize = 8        if resXi<=6:            eSize = 3        rSpacing = math.floor((inArr.shape[1] - eSize) / (originalInputArr.shape[0]-1))        cSpacing = math.floor((inArr.shape[2] - eSize) / (originalInputArr.shape[1]-1))        # eSize = (int)(math.ceil(rSpacing / ((resX)**2)))        # eSize = 2        # To get the spacing perfect we also need to add mod spacing        modRspacing = (inArr.shape[1] - eSize) % (originalInputArr.shape[0]-1)        modCspacing = (inArr.shape[2] - eSize) % (originalInputArr.shape[1]-1)        frS, frE = get_frame_intersect_by_timeRange((minAT-(timeIncr*5), maxAT+(timeIncr*5)), completeTimeRange)        # Don't overwrite other waves light up regions by finding out where the other waves are lit up.        # print("frS" + str(frS) + " frE:" + str(frE)              rSpacingRemainder = 0        # For each electrode row        for r in range(0, originalInputArr.shape[0]):            # For each electrode col            cSpacingRemainder = 0            for c in range(0, originalInputArr.shape[1]):                              r1 = (int)(round(r * rSpacing + rSpacingRemainder))                 r2 = (int)(round(r * rSpacing + rSpacingRemainder + eSize))                 c1 = (int)(round(c * cSpacing + cSpacingRemainder))                 c2 = (int)(round(c * cSpacing + cSpacingRemainder + eSize))                 if (r2 >= (newArr.shape[1])):                    r2 = newArr.shape[1] - 1                if (c2 >= (newArr.shape[2])):                    c2 = newArr.shape[2] - 1                                          if origI==1:                    # print(origI,"Paint electrodes black throughout, to be overwritten later")                    newArr[0:newArr.shape[0], r1:r2, c1:c2, 0] = 0.6                    newArr[0:newArr.shape[0], r1:r2, c1:c2, 1] = 0.6                                    newArr[0:newArr.shape[0], r1:r2, c1:c2, 2] = 0.6                    newArr[0:newArr.shape[0], r1:r2, c1:c2, 3] = 0.25                                  # print("newArr[frS, (r1+1), (c1+1), 0] ", newArr[frS, (r1+1), (c1+1), 0], " - ", newArr[frE, (r1+1), (c1+1), 0])                # if (newArr[frE, (r1+1), (c1+1), 0] < 0.99) and (newArr[frE, (r1+1), (c1+1), 0] < 0.99):                for frN in range(frS, frE):                    if (newArr[frN, r1, c1, 0] < 0.99):                        if np.isnan(originalInputArr[r,c]):                            # print("Found me a nan lets paint it brown!"                            newArr[frN, (r1+1):(r2-1), (c1+1):(c2-1), 0] = 0.6                            newArr[frN, (r1+1):(r2-1), (c1+1):(c2-1), 1] = 0.6                            newArr[frN, (r1+1):(r2-1), (c1+1):(c2-1), 2] = 0.6                            newArr[frN, (r1+1):(r2-1), (c1+1):(c2-1), 3] = 0.25                              # newArr = make_border_4d(newArr, frS, frE, r1, r2, c1, c2, "white")                        else:                            newArr[frN, (r1+1):(r2-1), (c1+1):(c2-1), 0] = 0.4                            newArr[frN, (r1+1):(r2-1), (c1+1):(c2-1), 1] = 0.4                            newArr[frN, (r1+1):(r2-1), (c1+1):(c2-1), 2] = 0.4                            newArr[frN, (r1+1):(r2-1), (c1+1):(c2-1), 3] = 0.7                        # newArr = make_border_4d(newArr, frS, frE, r1, r2, c1, c2, "white")                    # else:                    #     print("found ourselves an already lit up electrode = don't overwrite!")                    # print("MAKING BLACK!"                actTime = originalInputArr[r,c]                actStart = actTime                 actEnd = actTime + electrodeLightUpTime                actFrS, actFrE = get_frame_intersect_by_timeRange((actStart, actEnd), completeTimeRange)                # print("actFrS: " + str(actFrS) + " - " + "actFrE: " + str(actFrE)                # print("found me some ACTIVATION FRAMES, painting YELLOW(ish), well more like white for some reason"                newArr[actFrS : actFrE, r1 : r2, c1 : c2, 0] = 0.99                newArr[actFrS : actFrE, r1 : r2, c1 : c2, 1] = 0.99                              newArr[actFrS : actFrE, r1 : r2, c1 : c2, 2] = 0                newArr[actFrS : actFrE, r1 : r2, c1 : c2, 3] = 0.99                newArr = make_border_4d(newArr, actFrS, actFrE, r1, r2, c1, c2, "darkOrange")                if (c < modCspacing):                    cSpacingRemainder += 1            # To get the spacing perfect we also need to add mod spacing            if (r < modRspacing):                rSpacingRemainder += 1                        return newArr    def overlay_visualise_animation(inputDataEachWave, animation3dArray, completeTimeRange, addBorderToWave=True, overlayElecs=True, overlayCB=False, CBlist=None, cbGray=0.66):    if '_RED_' in inputWavesFile.upper():        makeRed = True    else:        makeRed = False    # make animation array rgb    animation3dArray = animation_arr_to_rgb(animation3dArray, makeRed)    if overlayCB:        animation3dArray = overlay_CB_animation(inputDataEachWave, animation3dArray, CBlist, timeIncr, completeTimeRange,cbGray)            if overlayElecs:        animation3dArray = overlay_elecs_on_animation(inputDataEachWave, animation3dArray, timeIncr, completeTimeRange)        if addBorderToWave:        animation3dArray = add_border_to_animation(animation3dArray)     # Add some simple padding around the wave animation for captioning and general aesthetics    animation3dArray, paddingVal = pad_3d_edges(animation3dArray)    return animation3dArray, paddingVal## ==== End Graphic manipulation functions