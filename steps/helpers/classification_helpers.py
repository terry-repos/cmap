import collectionsimport textwrapimport copyfrom copy import deepcopyfrom pyutils.string_utils import *from pyutils.list_utils import *from pyutils.io_utils import *from pyutils.np_arr_flipping import *from pyutils.np_arr_samples import *import numpy as npfrom sklearn.model_selection import StratifiedKFolddef get_folds( nFolds, labels, shuffle=True ) :	if nFolds > 0 :		pseudoData = np.copy(labels)		skf = StratifiedKFold( n_splits=nFolds, random_state=None, shuffle=False )		folds = skf.split( pseudoData, labels )	else :		folds = []	return foldsdef get_win_hierarchies( currentParams, labelsHier ) :	essntlHierarchies = copy.deepcopy( remove_this_list_from_that_list( currentParams['EventIrrelevantInputHiers'], labelsHier ))	winLblsHier =  copy.deepcopy( remove_this_list_from_that_list( copy.deepcopy( currentParams['winIrrelevantInputHiers']), copy.deepcopy( labelsHier ) ) )	return essntlHierarchies, winLblsHier	def alter_step_params_according_to_wins( currentParams, labelsHier, currStepParams ) :	essntlHierarchies, winLblsHier = get_win_hierarchies( currentParams, labelsHier )	# print( "essntlHierarchies: ", essntlHierarchies )	currStepParams['PARAMS'][ 'EVENTS_FROM_THIS_HIERARCHY' ] = copy.deepcopy( essntlHierarchies )	if list_contains_list(currStepParams['OUTPUT'][ 'PLOT_CHANS' ][ 'EVENT_MARKER_PARAMS' ][ 'EVENT_HIERARCHIES_TO_PLOT' ]) :		currStepParams['OUTPUT'][ 'PLOT_CHANS' ][ 'EVENT_MARKER_PARAMS' ][ 'EVENT_HIERARCHIES_TO_PLOT' ].extend( [copy.deepcopy( labelsHier )] )	else:		currStepParams['OUTPUT'][ 'PLOT_CHANS' ][ 'EVENT_MARKER_PARAMS' ][ 'EVENT_HIERARCHIES_TO_PLOT' ].append( [copy.deepcopy( labelsHier )] )	# if list_contains_list( currStepParams['OUTPUT'][ 'PLOT_CHANS' ][ 'EVENT_MARKER_PARAMS' ][ 'WIN_HIERARCHIES_TO_PLOT' ] ) :	# 	currStepParams['OUTPUT'][ 'PLOT_CHANS' ][ 'WIN_HIERARCHIES_TO_PLOT' ][0].append( [copy.deepcopy( winLblsHier )] )	# else :	# 	currStepParams['OUTPUT'][ 'PLOT_CHANS' ][ 'WIN_HIERARCHIES_TO_PLOT' ].append( [copy.deepcopy( winLblsHier )] )	essntlHierarchies, winLblsHier = get_win_hierarchies( currentParams, labelsHier )	currStepParams['PARAMS'][ 'METHODS' ] = 'WIN_BY_LABELS'	currStepParams['PARAMS'][ 'WINDOWS' ] = copy.deepcopy( currentParams['WINDOWS'] )	currStepParams['PARAMS'][ 'NUM_OF_NEIGHBOURING_CHANS_EITHER_SIDE' ] = currentParams['NUM_OF_NEIGHBOURING_CHANS_EITHER_SIDE']	currStepParams['PARAMS'][ 'OUTPUT_EVENTS_HIERARCHY' ] = copy.deepcopy( winLblsHier )	currStepParams['PARAMS'][ 'EVENTS_FROM_THIS_HIERARCHY' ] = copy.deepcopy( essntlHierarchies )	return currStepParamsdef get_classification_params( ID, currentParams ) :	classParams = copy.deepcopy( currentParams )	classParams[ 'nnName' ] = ID	if 'HIDDEN_UNITS' in currentParams.keys() :		classParams['HddnUnitsStr'] = 'Hddn' + list_as_str( currentParams['HIDDEN_UNITS'], "-" )		classParams['nnName'] += classParams['HddnUnitsStr']	if 'NUM_TRAINING_STEPS' in currentParams.keys() :		classParams['nTrainingSteps'] = currentParams[ 'NUM_TRAINING_STEPS' ]		classParams['nTrainingStepsStr'] = "Stps" + str( currentParams[ 'NUM_TRAINING_STEPS' ] )		classParams['nnName'] += classParams['nTrainingStepsStr']	if 'NUM_OF_NEIGHBOURING_CHANS_EITHER_SIDE' in currentParams.keys() :		classParams['nNbChns'] = currentParams[ 'NUM_OF_NEIGHBOURING_CHANS_EITHER_SIDE' ]		classParams['chansStr'] = "nNbChns" + str( currentParams[ 'NUM_OF_NEIGHBOURING_CHANS_EITHER_SIDE' ] )					classParams['nnName'] += classParams['chansStr']	if 'WINDOWS' in currentParams.keys() :		classParams['winRange'] = copy.copy( currentParams['WINDOWS'] )		classParams['winStr'] = "WnS" + str( currentParams['WINDOWS'][0]) + "WnE" + str( currentParams['WINDOWS'][1] )		classParams['nnName'] += classParams['winStr']	if 'NUM_CROSS_VALIDATION_FOLDS' in currentParams.keys() :		classParams['nFolds'] = currentParams['NUM_CROSS_VALIDATION_FOLDS']	else:		classParams['nFolds'] = 0	classParams['EventIrrelevantInputHiers'] = [ 'Predict', classParams['chansStr'], classParams['winStr'], classParams['nTrainingStepsStr'], classParams['HddnUnitsStr'] ]	classParams['winIrrelevantInputHiers'] = [ 'Predict', classParams['nTrainingStepsStr'], classParams['HddnUnitsStr'] ]	classParams['winSize'] = classParams['winRange'][1] - classParams['winRange'][0]	# classParams['nChans'] = classParams['nNbChns']	classParams['featureSize'] = classParams['winSize'] * ( ( classParams['nNbChns'] * 2 ) + 1 )	if classParams['featureSize'] == 0 :		print("The feature size is 0 which means training cannot take place. Please check your win window parameters.")	return classParamsdef get_classification_data_hierarchies( ID, currentParams, origNNparams, dataDirectories ) :	hierarchies = {}	hierarchies['inputStrs'] = []	lblI = 0			print( "currentParams: ", currentParams )	if 'TRAIN' in origNNparams['METHODS'] :						hierarchies['trainHierarchies'] = list( copy.deepcopy( origNNparams['LABEL_HIERARCHIES'] ) )		hierarchies['nLbls'] = len( hierarchies[ 'trainHierarchies' ] )		for nlblH in range( 0, hierarchies['nLbls'] ) :			if currentParams[ 'winStr' ] not in hierarchies[ 'trainHierarchies' ][ nlblH ] :									hierarchies[ 'trainHierarchies' ][ nlblH ].insert( 0, copy.copy( currentParams[ 'winStr' ] ) )				if currentParams[ 'chansStr' ] not in hierarchies[ 'trainHierarchies' ][ nlblH ] :				hierarchies[ 'trainHierarchies' ][ nlblH ].insert( 0, copy.copy( currentParams[ 'chansStr' ] ) )			if currentParams[ 'nTrainingStepsStr' ] not in hierarchies[ 'trainHierarchies' ][ nlblH ] :														hierarchies[ 'trainHierarchies' ][ nlblH ].insert( 0, copy.copy( currentParams[ 'nTrainingStepsStr' ] ) )				if currentParams[ 'HddnUnitsStr' ] not in hierarchies[ 'trainHierarchies' ][ nlblH ] :				hierarchies[ 'trainHierarchies' ][ nlblH ].insert( 0, copy.copy( currentParams[ 'HddnUnitsStr' ] ) )				hierarchies['labelHierarchies'] = copy.deepcopy( hierarchies[ 'trainHierarchies' ] )		hierarchies[ 'inputHiers' ] = copy.deepcopy( hierarchies['labelHierarchies'] ) 					elif 'PREDICT_INPUT_HIERARCHY' in currentParams.keys() :		hierarchies[ 'inputHiers' ] = list( copy.deepcopy( currentParams['PREDICT_INPUT_HIERARCHY'] ) )		hierarchies[ 'inputHiers' ][0].insert( 0, copy.copy( currentParams['chansStr'] ) )		hierarchies[ 'inputHiers' ][0].insert( 1, copy.copy( currentParams['winStr'] ) )			hierarchies['essntlPredictInputHier'] = remove_this_list_from_that_list( currentParams['EventIrrelevantInputHiers'], hierarchies['inputHiers'] ) 		hierarchies[ 'labelHierarchies' ] = list( copy.deepcopy( currentParams['LABEL_HIERARCHIES'] ) )		hierarchies['nLbls'] = len( hierarchies['labelHierarchies'] )		for nlblH in range( 0, hierarchies['nLbls'] ) :				if currentParams['winStr'] not in hierarchies[ 'labelHierarchies' ][ nlblH ] :									hierarchies[ 'labelHierarchies' ][ nlblH ].insert( 0, copy.copy( currentParams['winStr'] ) )			if currentParams['chansStr'] not in hierarchies[ 'labelHierarchies' ][ nlblH ] :				hierarchies[ 'labelHierarchies' ][ nlblH ].insert( 0, copy.copy( currentParams['chansStr'] ) )								if currentParams['nTrainingStepsStr'] not in hierarchies[ 'labelHierarchies' ][ nlblH ] :														hierarchies[ 'labelHierarchies' ][ nlblH ].insert( 0, copy.copy( currentParams['nTrainingStepsStr'] ) )			if currentParams['HddnUnitsStr'] not in hierarchies[ 'labelHierarchies' ][ nlblH ] :				hierarchies[ 'labelHierarchies' ][ nlblH ].insert( 0, copy.copy( currentParams['HddnUnitsStr'] ) )									hierarchies[ 'labelHierarchies' ][ nlblH ].insert( 0, 'Predict' )			# Add these output events for plotting			# Initialise these output events in dict			# print_keys_hierarchy(g.dat[ ID ][ 'Events' ], "EVENTS PRE")			# g.dat[ ID ][ 'Events' ] = copy.deepcopy( update_dict_with_a_new_initialised_hierarchy( g.dat[ID]['Events'], hierarchies[ 'labelHierarchies' ][ nlblH ], get_nChans()) )			# print_keys_hierarchy(g.dat[ ID ][ 'Events' ], "EVENTS POST")	if 'WIN_HIERARCHIES_TO_PLOT' not in g.cur['STEP']['OUTPUT']['PLOT_CHANS'].keys() :		g.cur['STEP']['OUTPUT']['PLOT_CHANS']['WIN_HIERARCHIES_TO_PLOT'] = []	hierarchies['essntlLblHierarchies'] = []	# hierarchies['essntlLblHierarchiesStrs'] = []		if 'nnNameStr' in locals():		del nnNameStr	nnNameStr = currentParams['nnName']	print( "hierarchies['labelHierarchies']: ", hierarchies['labelHierarchies'] )	print( "hierarchies['essntlLblHierarchies']: ", hierarchies['essntlLblHierarchies'] )	for lblHier in hierarchies['labelHierarchies'] :		# print("currentParams[ 'EventIrrelevantInputHiers' ]: ", currentParams[ 'EventIrrelevantInputHiers' ])		essntLblHier = copy.deepcopy(remove_this_list_from_that_list( currentParams[ 'EventIrrelevantInputHiers' ], lblHier ))		hierarchies[ 'essntlLblHierarchies' ].append( essntLblHier  )		# print("lblHier: ", lblHier)		tempList = copy.deepcopy( lblHier )		# lbl = str( tempList.pop() ) + str( tempList.pop() )		lbl = copy.deepcopy( list_as_str( tempList, "" ).replace( 'Predict', '' ) )		hierarchies[ 'inputStrs' ].append( lbl )			if not lblI==(hierarchies['nLbls'] - 1) :			nnNameStr += copy.deepcopy( list_as_str( essntLblHier, "") )			nnNameStr += "VS"		else :			nnNameStr += copy.deepcopy( list_as_str( essntLblHier, "") )		lblI+=1				# print("hierarchies[ 'essntlLblHierarchies' ]: ", hierarchies[ 'essntlLblHierarchies' ])	# print("PRIOR currentParams['nnName']: ", currentParams)	if 'nnName' in currentParams.keys() :		currentParams.pop('nnName', 0)	currentParams['nnName'] = nnNameStr	return hierarchiesdef build_nn_param_variations( params ) :	paramsVariations = []	params = copy.copy( params )	if 'NN_MODEL_TO_LOAD' in params.keys() :		nnModelsToLoad = params['NN_MODEL_TO_LOAD']				for nnModelToLoad in nnModelsToLoad :			tempParams = {}			tempParams = copy.deepcopy( params )						tempParams['NUM_OF_NEIGHBOURING_CHANS_EITHER_SIDE'] = get_int_vals_from_str( nnModelToLoad, prefix="nNbChns" )			winStart = get_int_vals_from_str( nnModelToLoad, prefix="WnS" )			winEnd = get_int_vals_from_str( nnModelToLoad, prefix="WnE" )			tempParams['WINDOWS'] = [ winStart, winEnd ]			tempParams['HIDDEN_UNITS'] = get_int_vals_from_str( nnModelToLoad, prefix="Hddn" )			tempParams['NUM_TRAINING_STEPS'] = get_int_vals_from_str( nnModelToLoad, prefix="Stps" )			tempParams['NN_MODEL_TO_LOAD'] = nnModelToLoad			paramsVariations.append( copy.deepcopy( tempParams ) )	else :		for nChans in params['NUM_OF_NEIGHBOURING_CHANS_EITHER_SIDE'] :			tempParams = {}			tempParams = copy.deepcopy( params )			for windowss in params['WINDOWS'] :				for HddnUnits in params['HIDDEN_UNITS'] :					for trainingStep in params['NUM_TRAINING_STEPS'] :						tempParams['NUM_OF_NEIGHBOURING_CHANS_EITHER_SIDE'] = nChans						tempParams['WINDOWS'] = list(windowss)						tempParams['HIDDEN_UNITS'] = list(HddnUnits)						tempParams['NUM_TRAINING_STEPS'] = trainingStep						# print("tempParams: ", tempParams)						paramsVariations.append(copy.deepcopy(tempParams))	return paramsVariationsdef build_mid_wave_param_variations( params ) :	paramsVariations = []	params = copy.copy( params )	parOutPerc = params["OUTLIER_PERCENTILE"]	parMinWidth = params["MIN_WAVE_WIDTH"]	parMaxWidth = params["MAX_WAVE_WIDTH"]	parSol = params["REFRACTORY_PERIOD"]	outlierPercentileRange = range( parOutPerc[0], parOutPerc[1], parOutPerc[2] )	minWidthRange = range( parMinWidth[0], parMinWidth[1], parMinWidth[2] )	maxWidthRange = range( parMaxWidth[0], parMaxWidth[1], parMaxWidth[2] )	gapDefiningSol = range( parSol[0], parSol[1], parSol[2] )		for outlierPerc in outlierPercentileRange :		tempParams = {}		tempParams = copy.deepcopy( params )		tempParams["OUTLIER_PERCENTILE"] = outlierPerc		for minWidth in minWidthRange :			tempParams["MIN_WAVE_WIDTH"] = minWidth					for gap in gapDefiningSol :				tempParams["REFRACTORY_PERIOD"] = gap				for maxWidth in maxWidthRange :					tempParams["MAX_WAVE_WIDTH"] = maxWidth					if 'MAX_DISTANCE_FROM_REFERENCE_EVENT' in tempParams.keys():						if tempParams['MAX_DISTANCE_FROM_REFERENCE_EVENT']==None :							tempParams["MAX_DISTANCE_FROM_REFERENCE_EVENT"] = parMinWidth[0]					if tempParams["MIN_WAVE_WIDTH"] < tempParams["MAX_WAVE_WIDTH"] :						paramsVariations.append( copy.deepcopy(tempParams) )	return paramsVariations	def build_group_propagating_param_variations( params ) :	paramsVariations = []	params = copy.copy( params )	parMinDelay = params["MIN_DELAY"]	parMaxDelay = params["MAX_DELAY"]	parMinChansSubGroup = params["MIN_CHANS_TO_FORM_SUB_GROUP"]	parMinChansGroup = params["MIN_CHANS_TO_FORM_GROUP"]	parNghbChan = params["NEIGHBOUR_SPAN"]	minChansSubGroupRange = range( parMinChansSubGroup[0], parMinChansSubGroup[1], parMinChansSubGroup[2] )	minChansGroupRange = range( parMinChansGroup[0], parMinChansGroup[1], parMinChansGroup[2] )	minDelayRange = range( parMinDelay[0], parMinDelay[1], parMinDelay[2] )	maxDelayRange = range( parMaxDelay[0], parMaxDelay[1], parMaxDelay[2] )	nghbChanRange = range( parNghbChan[0], parNghbChan[1], parNghbChan[2] )		for nghbChan in nghbChanRange :		tempParams = {}		tempParams = copy.deepcopy( params )			tempParams["NEIGHBOUR_SPAN"] = nghbChan					for minChansSubGroup in minChansSubGroupRange :			if minChansSubGroup < nghbChan :				tempParams["MIN_CHANS_TO_FORM_SUB_GROUP"] = minChansSubGroup				for minChansGroup in minChansGroupRange :					tempParams["MIN_CHANS_TO_FORM_GROUP"] = minChansGroup					for minDelay in minDelayRange :						tempParams["MIN_DELAY"] = minDelay								for maxDelay in maxDelayRange :							tempParams["MAX_DELAY"] = maxDelay												if tempParams["MIN_DELAY"] < tempParams["MAX_DELAY"] :								paramsVariations.append( copy.deepcopy(tempParams) )	return paramsVariations		