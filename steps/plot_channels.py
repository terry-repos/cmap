from global_imports import session_vars as gfrom global_imports.simplify_vars import *from pyutils.io_utils import *from pyutils.time_utils import *from pyutils.dict_utils import *from pyutils.np_arr_samples import *from hierarchies.hierarchies_events import *from hierarchies.indexing_events import *from hierarchies.indexing_wins import *import mathif 'plt' in globals() or 'plt' in locals():	del pltimport matplotlib.pyplot as pltimport matplotlib.animation as animationimport matplotlib.colors as colorsfrom matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvasfrom matplotlib.figure import Figurefrom matplotlib import pyplot as pltimport matplotlib.transforms as tximport matplotlib.patches as mpatchesfrom matplotlib.pyplot import cmfrom matplotlib.font_manager import FontPropertiesimport matplotlib.mlab as mlabimport numpy as npclass PlotChannels():	def __init__(self):		g.command_history.add('', __name__,g.inspect.stack()[0][3], locals())		self.stepDir = get_step_dir()		print("=== BEGINNING PLOTTING FOR STEP === ", self.stepDir)		self.ID, self.nSamples, self.nChans, self.sampleRate, self.params, self.sl = make_globals_readable()		# print("self.params: ", self.params)		self.timestamps = g.dat[self.ID]['Timestamps']		self.evDataParams = g.loadDataParams['DATA']['Events']		self.dataInfo = g.dat[self.ID]['ChanConfig']		self.plotPars = {}		self.plotPars['ALL'] = g.cur['STEP']['OUTPUT']['PLOT_CHANS']		self.plotPars['FIGS'] = self.plotPars['ALL']['FIG_PARAMS']		self.plotPars['IO'] = self.plotPars['ALL']['IO_PARAMS']		self.plotPars['EVENT_MARKERS'] = self.plotPars['ALL']['EVENT_MARKER_PARAMS']		if 'SAMPLE_WINDOWS' in self.plotPars['ALL'].keys() :			self.plotPars['SAMPLE_WINDOWS'] = self.plotPars['ALL']['SAMPLE_WINDOWS']		self.plotPars['EVENT_MARKERS'] = self.plotPars['ALL']['EVENT_MARKER_PARAMS']		# print("self.plotPars: ", self.plotPars)		if 'TIME_BETWEEN_SAMPLES' in self.dataInfo.keys() :			self.timeBetweenSamples =  self.dataInfo['TIME_BETWEEN_SAMPLES']		if self.plotPars['IO']['ADD_STEP_AS_NEW_SUB_FOLDER'] :			self.plotPath = create_dir( [ g.params['OUT_ROOT'], self.plotPars['IO']['SUB_FOLDER'], self.stepDir] )		else :			self.plotPath = create_dir( [ g.params['OUT_ROOT'], self.plotPars['IO']['SUB_FOLDER'] ] )		# print("g.cur['STEP']['PARAMS']: ", g.cur['STEP']['PARAMS'])		plotWins = False		if 'win' in self.stepDir.upper() :			plotWins = True		elif 'PREDICT_OFFLINE_winS' in  g.cur['STEP']['PARAMS'].keys() :			if g.cur['STEP']['PARAMS']['PREDICT_OFFLINE_winS'] :				plotWins = True		elif 'WIN_HIERARCHIES_TO_PLOT' in self.plotPars['ALL'].keys() :			plotWins = True		if 'PERFORM_PLOT_WINDOWS' in self.plotPars['ALL'].keys() :			if self.plotPars['ALL']['PERFORM_PLOT_WINDOWS'] :				plotWins = True			else:				plotWins = False		if 'Events' in g.dat[ self.ID ].keys() :			if self.plotPars['EVENT_MARKERS']['PLOT_EVENTS'] :				self.plotPars['MARKER_STYLING'] = self.plotPars['EVENT_MARKERS']['MARKER_STYLING']					allHierarchies = get_all_hierarchies_lists_containing_valid_indices( dict(g.dat[self.ID]['Events']) )				print("allHierarchies: ", allHierarchies)				# print_keys_hierarchy( g.dat[self.ID]['Events'] )				# quit()								self.stylingDict = get_styles_for_levels_in_hierarchy( self.evDataParams, self.plotPars['MARKER_STYLING'], allHierarchies )				# print("self.stylingDict: ", self.stylingDict)				# quit()		if 'NN_RESULTS' in self.plotPars[ 'ALL' ].keys() :			specPlotTitleStr = list_as_str(self.plotPars[ 'ALL' ]['NN_RESULTS'])		else:			specPlotTitleStr = ""		plotWins = False		if plotWins :			# print("in win!")			winHierarchies = get_all_hierarchies_lists_containing_valid_indices( dict( g.dat[self.ID]['Windows'] ) )			# print("g.dat[self.ID]['Windows']: ", g.dat[self.ID]['Windows'])			winHlist = get_intersect_of_all_hierarchies_and_specified( winHierarchies, self.plotPars[ 'ALL' ][ 'WIN_HIERARCHIES_TO_PLOT' ][0] )			# print_keys_hierarchy( g.dat[self.ID]['Windows'] )			# print( "All winHierarchies: ", winHierarchies )			if not list_contains_list( winHlist ) :				winHlist = [list(winHlist)]			print("winHlist: ", winHlist)			winI = 0			epocEvntHiersToPlot = []			for winH in winHlist :				thiswinData = np.copy( get_vals_from_dict_with_this_hierarchy( dict( g.dat[self.ID]['Windows'] ), copy.deepcopy( winH ), np.s_[::] ) )				if len(thiswinData) > 0 :					if 'winData' in locals() :						midEventIndex, winData = merge_arrays_horizontally( winData, thiswinData )					else:						winData = thiswinData						midEventIndex = round( thiswinData.shape[1]/2 )					nWins = thiswinData.shape[0]									evntsEpocList = list(copy.deepcopy(winH))					evntsEpocList.insert(0, 'EvntsWn')					epocEvntHiersToPlot.append(evntsEpocList)					g.dat[ self.ID ][ 'Events' ] = create_events_for_this_hierarchy_synched_across_chans( dict( g.dat[self.ID]['Events'] ), evntsEpocList, midEventIndex, nWins )					# eventsHierarchy = 					print_keys_hierarchy( g.dat[ self.ID ][ 'Events' ], " Event hiers, in plotchans()" )					print( "Found ", nWins, " for ", winH, " with shape ", list_as_str(thiswinData.shape) )					# print( g.dat[self.ID]['Windows'] )						totalwins = winData.shape[0]			self.data = winData			if nWins > 0 :				chanOrder = range( nWins, self.data.shape[1] )				self.channelsWindows, self.nChanstoPlot = self.create_chan_windows( chanOrder, self.plotPars['FIGS']['MAX_NUM_OF_CHANNELS_PER_WINDOW'], nWins, self.plotPars['ALL']['CHANNELS_SUBSETS'] )						# self.plotPars[ 'EVENT_MARKERS' ][ 'PLOT_EVENTS' ] = False				self.nSamples = self.data.shape[1]				self.sampWins = self.create_samples_windows( self.plotPars['ALL']['SAMPLES_SUBSETS'], self.plotPars['FIGS']['MAX_LENGTH_OF_DATA_PER_WINDOW'], self.nSamples )				# print("self.plotPars[ 'ALL' ]['NN_RESULTS']: ", self.plotPars[ 'ALL' ]['NN_RESULTS'])				self.plot_channels( epocEvntHiersToPlot, str(winI), isWindows=True, specPlotTitle=specPlotTitleStr)				winI += 1		# self.data = np.copy( g.dat[self.ID]['Samples'] )		self.data = g.dat[self.ID]['Samples']		self.channelsWindows, self.nChanstoPlot = self.create_chan_windows( self.dataInfo['CHANNEL_ORDER'], self.plotPars['FIGS']['MAX_NUM_OF_CHANNELS_PER_WINDOW'], self.nChans )				if self.data.shape[1] == 0:			print("Cannot plot empty data.")			quit()		self.sampWins = self.create_samples_windows( self.plotPars['ALL']['SAMPLES_SUBSETS'], self.plotPars['FIGS']['MAX_LENGTH_OF_DATA_PER_WINDOW'], self.nSamples )			if 'Events' in g.dat[ self.ID ].keys() and self.plotPars['EVENT_MARKERS']['PLOT_EVENTS'] :				# print("self.data.shape[1]: ", self.data.shape[1])			# self.mkrs = []			# print("print_keys_hierarchy(g.dat[self.ID]['Events'])")			# print_keys_hierarchy( g.dat[self.ID]['Events'], " event hierarchies in plotChannels().")			# print("self.plotPars['EVENT_MARKERS'][EVENT_HIERARCHIES_TO_PLOT]: ", self.plotPars['EVENT_MARKERS']["EVENT_HIERARCHIES_TO_PLOT"])			self.eventsPlots = []			self.eventsPlots = list( self.plotPars['EVENT_MARKERS']["EVENT_HIERARCHIES_TO_PLOT"] )			# print("allHierarchies: ", allHierarchies)			print("self.eventsPlots: ", self.eventsPlots)			print_keys_hierarchy( g.dat[self.ID]['Events'], " event hierarchies in plotChannels().")			# self.eventsPlots = [ allHierarchies ]			# if 'EVENT_HIERARCHIES_TO_PLOT' in self.plotPars['EVENT_MARKERS'].keys() :			# 	if len(self.plotPars['EVENT_MARKERS']["EVENT_HIERARCHIES_TO_PLOT"]) > 0 :			# 		if len(self.plotPars['EVENT_MARKERS']["EVENT_HIERARCHIES_TO_PLOT"][0]) > 0 :									# 			if list_contains_list_of_list( self.plotPars['EVENT_MARKERS']["EVENT_HIERARCHIES_TO_PLOT"]) :			# 				tempEventsPlots = []			# 				for specifiedMkrsHierarchies in self.plotPars['EVENT_MARKERS']["EVENT_HIERARCHIES_TO_PLOT"]:			# 					gettingHierarchies =  get_intersect_of_all_hierarchies_and_specified( allHierarchies, specifiedMkrsHierarchies )			# 					print( "gettingHierarchies: ", gettingHierarchies )			# 					self.eventsPlots.append(gettingHierarchies )			# 			else :			# 				self.eventsPlots = list( self.plotPars['EVENT_MARKERS']["EVENT_HIERARCHIES_TO_PLOT"] )			# 		# print("allHierarchies: ", allHierarchies)			# 		print("self.eventsPlots: ", self.eventsPlots)			mkrHierarchyI = 0			print("self.eventsPlots: ", self.eventsPlots)			if list_contains_list_of_list_of_lists(self.eventsPlots):				print("list contains list of list")				self.eventsPlots = copy.deepcopy( self.eventsPlots[0] )			print("self.eventsPlots: ", self.eventsPlots)			if list_contains_list_of_list_of_lists(self.eventsPlots):				print("list contains list of list")				self.eventsPlots = copy.deepcopy( self.eventsPlots[0] )			print("self.eventsPlots: ", self.eventsPlots)						# if list_contains_list_of_list(self.eventsPlots):			# 	print("list contains list of list")			# 	self.eventsPlots = copy.deepcopy( self.eventsPlots[0] )							# print("self.eventsPlots: ", self.eventsPlots)			for mkrHiers in self.eventsPlots :				self.plot_channels( mkrHiers, str(mkrHierarchyI), specPlotTitle=specPlotTitleStr )				mkrHierarchyI+=1		else :			self.plot_channels()				def plot_channels(self, mkrsHierarchies=[], iteration="", isWindows=False, specPlotTitle="") :		print("in plot chans")		labelStrList = []			uniqueMkrList = []		chanWindowI = 0				markerIndicesCount = {}		if len(mkrsHierarchies) > 0 :			# print("prior mkrsHierarchies: ", mkrsHierarchies)			if not list_contains_list(mkrsHierarchies) :				mkrsHierarchies = [ mkrsHierarchies ]			# print("post mkrsHierarchies: ", mkrsHierarchies)		for mkrs in mkrsHierarchies :			if len( mkrs ) > 0:				print("mkrs: ", mkrs)				mkrHierarchiesStr = list_as_str(mkrs, "_")				markerIndicesCount[mkrHierarchiesStr] = 0		for chanWindow in self.channelsWindows:			chanWindowI += 1			subPlotPath = self.plotPath			if len(self.channelsWindows) > 1 :				chansWindowsStr = ("CHANS_" + str(chanWindow[0]).zfill(2) + "-" + str(chanWindow[1]).zfill(2) )								if self.plotPars[ 'IO' ][ 'ADD_CHANS_AS_NEW_SUB_FOLDER' ] :					subPlotPath = create_dir( [self.plotPath, chansWindowsStr] )			sampWinI = 0			print("self.sampWins: ", self.sampWins)			for self.sampWin in self.sampWins :				windowMkrsCount = {}				for mkrs in mkrsHierarchies :					if len( mkrs ) > 0:						mkrHierarchiesStr = list_as_str(mkrs, "_")						windowMkrsCount[mkrHierarchiesStr] = 0				nSamplesInWindow = self.sampWin[1] - self.sampWin[0]				nChansInWindow = chanWindow[1] - chanWindow[0]								# print("Creating figure canvas.")				#Close canvases open in memory				plt.close("all")				plt.clf()				plt.cla()				plt.close()				if len(self.plotPars['FIGS']['FIGURE_SIZE']) > 0:					fig = plt.figure(figsize=self.plotPars['FIGS']['FIGURE_SIZE'])   								else :									# scaler = 0.4					# samplesToChanRatio = nSamplesInWindow / nChansInWindow					# figWidth = round( (samplesToChanRatio / 60) * scaler)					# figHeight = round( (samplesToChanRatio * 4.6) * scaler)					figWidth = 170					figHeight = 105					if 'fig' in globals() or 'fig' in locals() :						del fig					fig = plt.figure(figsize=(figWidth, figHeight)) 				# print( g.cur['STEP']['PARAMS'] )				sampWinI += 1								tempPlotPath = subPlotPath				if self.plotPars['IO']['ADD_STEP_TO_FILENAME_SUFFIX'] :					plotFileName = create_filename([ self.ID,  self.stepDir, "" ]) 				else :					plotFileName = create_filename([ self.ID, ""]) 				if isWindows:					plotFileName = create_filename([ plotFileName, "wins", "" ])				sampleWindowsStr = str(sample_val_to_time(self.sampWin[0], self.timeBetweenSamples, self.data.shape[1])).zfill(2) + \					"_-_" + str(sample_val_to_time(self.sampWin[1], self.timeBetweenSamples, self.data.shape[1])).zfill(2)				if len(self.sampWins) > 1 :					plotTitle = self.ID + "    " + self.stepDir + "    " + sampleWindowsStr					if self.plotPars['IO']['ADD_WINDOWS_AS_NEW_SUB_FOLDER'] :						tempPlotPath = create_dir([subPlotPath, sampleWindowsStr])										plotFileName = create_filename([plotFileName, sampleWindowsStr, ""])				else :					plotTitle = self.ID + "    " + self.stepDir + "    " 				if len(self.channelsWindows) > 1 :					plotFileName =  create_filename([plotFileName, chansWindowsStr, ""])				mkrHierarchiesStr = list_as_str(mkrsHierarchies,"_")[:150]				plotFileName = create_filename([plotFileName, iteration, mkrHierarchiesStr, '.png'])									plotPathAndFileName = tempPlotPath + plotFileName				if not 'LOAD_DATA' in self.stepDir.upper() :					beautifiedParams = self.streamline_params(self.params)								plotTitle += "  " + dict_to_text_wrapped_string(beautifiedParams, 150)				if not len(specPlotTitle)==0 :					plotTitle = specPlotTitle				fig.suptitle(plotTitle, fontsize=self.plotPars['FIGS']['TITLE_FONT_SIZE'], x = 0.5, y = 1.015)				# Purely testing index marking:				# plt.axvline(x=testAXmidpoint, linewidth=10, color='black')								# testAXmidpoint = round((sampWin[1] - sampWin[0]) / 2) + sampWin[0]				# print(testAXmidpoint)				# print( "Plot title: ", plotTitle )				for chan in range(chanWindow[0], chanWindow[1]) :					ax = plt.subplot(chanWindow[1], 1, (chan-chanWindow[0]+1))					samplesSubset = np.array(self.data[chan, self.sampWin[0] : self.sampWin[1]])					timestampsSubset = np.array(self.timestamps[self.sampWin[0] : self.sampWin[1]])					indicesSubset = np.linspace(self.sampWin[0], self.sampWin[1], self.sampWin[1] - self.sampWin[0])					minValue = np.min(samplesSubset)					maxValue = np.max(samplesSubset)					valueStep = (maxValue - minValue) / 10					ax.plot(indicesSubset, samplesSubset, color="black", linewidth=self.plotPars['FIGS']['LINEWIDTH'])					ax.autoscale_view(tight=True, scalex=False, scaley=False)					plt.ylabel(str(chan+1), fontsize=40)					plt.xlim([ indicesSubset[0], indicesSubset[-1]])					plt.yticks([])					plt.tick_params(labelleft=True, direction='out')					if chan==(chanWindow[1]-1) :						plt.tick_params(axis='x', labelsize=40)					else :						plt.tick_params(axis='x', bottom=False, left=False, right=False, top=False)						plt.xticks([])					textY = maxValue - minValue * 3					allLables = []					lims = plt.gca().get_ylim()					if self.plotPars['EVENT_MARKERS']['PLOT_EVENTS'] :						if not mkrsHierarchies==None :							if 'Events' in g.dat[self.ID].keys() :								# print("Beginning to add markers to plot for chan ", str(chan))								for mkrs in mkrsHierarchies :									# if chan==0 :									# 	print_keys_hierarchy(g.dat[self.ID]['Events'], " events hierarchy.")									# 	print(self.sampWin, " in event plotting, mkrs: ", mkrs)									if len( mkrs ) > 0 :										mkrParams = dict( self.match_params_with_hierarchy( mkrs, self.plotPars['EVENT_MARKERS']['DEFAULT_MARKER_STYLING'] ) )										indices = get_indices_that_contains_all_specified_hierarchies( dict( g.dat[ self.ID ][ 'Events' ] ), mkrs, np.s_[chan], True, self.sampWin )										labelStr = list_as_str(mkrs,"_")										markerIndicesCount[labelStr] += indices.shape[0]										windowMkrsCount[labelStr] += indices.shape[0]										if len(indices) > 0 :											# print_keys_hierarchy(markerIndicesCount, "markerIndicesCount")											# print("labelStr: ", labelStr)											if self.plotPars['EVENT_MARKERS']["WIDDEN_INDICES"]:												leftIndicesNeighbours = indices-3												# leftIndicesNeighbours2 = indices-6												rightIndicesNeighbours = indices+3												# rightIndicesNeighbours2 = indices+6												# widdenedIndices = np.concatenate((indices, leftIndicesNeighbours, rightIndicesNeighbours,  leftIndicesNeighbours2, rightIndicesNeighbours2))												indices = np.concatenate((indices, leftIndicesNeighbours, rightIndicesNeighbours))											if not labelStr in labelStrList:												# print("plotting with labelstr: ", labelStr)												labelStrList.append(labelStr)												if not mkrParams in uniqueMkrList:												# print("plotting with labelstr: ", labelStr)												uniqueMkrList.append(mkrParams)																				# print("labelStr: ", labelStr," mkrParams: ", mkrParams)											ax.vlines(indices, ymin=lims[0], ymax=lims[1], **mkrParams)												# print("indicesSubset: ", indicesSubset, " indices: ", indices)					else :						midIndex = (self.data.shape[1] / 2)						ax.vlines(midIndex, ymin=lims[0], ymax=lims[1], color='blue', linewidth=10)					totalMarkers = 0				for value in windowMkrsCount.values():					totalMarkers += value									# print(self.plotPars['EVENT_MARKERS'])				# quit()				if not self.plotPars['EVENT_MARKERS']['ONLY_PLOT_WINDOWS_WITH_EVENTS'] or (totalMarkers > 0):					# red_patch = mpatches.Patch(color='red', label='The red data')					# plt.legend(handles=[red_patch])					patchesLbls = []					if self.plotPars['EVENT_MARKERS']['PLOT_EVENTS'] :						# print("labelStrList: ", labelStrList)						for lbl, mpars in zip(labelStrList, uniqueMkrList) :							print("lbl: ",lbl, " mpars: ", mpars )							patchLbl = mpatches.Patch(color=mpars['color'], label=lbl)							patchesLbls.append(patchLbl)					else :						# print("uniqueMkrlist len = 0")						winLabel = list_as_str( mkrsHierarchies )						patchLbl = mpatches.Patch(color='blue', label=winLabel)						patchesLbls.append(patchLbl)					legend = plt.legend(loc='lower right', handles=patchesLbls, fontsize=self.plotPars['FIGS']['LEGEND_FONT_SIZE'])					fig.subplots_adjust(left=0.1, right=1, bottom=0.1, top=1, hspace=0, wspace=0)					if len(plotPathAndFileName) > 0:						# print("Finished making plots, now saving fig.")						try :							fig.savefig(plotPathAndFileName, bbox_inches='tight', pad_inches=0.5, dpi=self.plotPars['FIGS']['DPI'])  							del fig						except Exception as e :							print("e: ", e)							quit()		print( "Markers: ", mkrsHierarchies, " ", markerIndicesCount )	def match_params_with_hierarchy( self, hierarchLst, defaultParams ) :		outParams = defaultParams		if list_contains_list(hierarchLst) :			hierarchLst = copy.deepcopy(hierarchLst[0])		if list_contains_list(hierarchLst) :			hierarchLst = copy.deepcopy(hierarchLst[0])					for room in hierarchLst :			if room in self.stylingDict.keys() :				if self.stylingDict[room]['styler'] :					outParams[self.stylingDict[room]['styler']] = self.stylingDict[room]['val']		return outParams		def traverse_events_structure_plot_events(self, inEventsDict, currHierarchy) :		unitLevel = 0		paramsDict.update({ self.mkrStyling['AUTO_STYLER'] : self.mkrStyling['AUTO_VALUES'][automationLevel] })		paramsDict.update({ self.mkrStyling['EV_STYLER'] : self.mkrStyling['EV_VALUES'][eventLevel] })		for dictType, value in inEventsDict.items() :			# print("DictType: ", dictType, " events label: ", evLbl)			if 'ndarray' in str(type(value)):				unitLevel += 1					if unitLevel > (nUnits-1):					unitLevel = 0				if len(value.shape) > 1 :					indices = value[inChan,:]				else:					indices = []				paramsDict.update({ self.mkrStyling['UNIT_STYLER'] : self.mkrStyling['UNIT_VALUES'][unitLevel]} )										if len(indices) > 0:					self.plot_events(indices,  paramsDict, [autLbl, evLbl, subEvLbl, dictType])			elif isinstance(value, dict):				if nSubEvents > 0:					paramsDict.update({self.mkrStyling['SUB_EV_STYLER'] : self.mkrStyling['SUB_EV_VALUES'][subEventLevel]})											if not isinstance(value[get_first_key_in_dict(value)], dict):						subEventLevel += 1					if subEventLevel > (nSubEvents-1):						subEventLevel = 0									subEvLbl = dictType				self.traverse_events_structure_plot_events(autLbl, evLbl, subEvLbl, value, inChan, nSubEvents, nUnits, automationLevel, eventLevel, subEventLevel, unitLevel, paramsDict)	def create_chan_windows(self, chanOrder, numChannelsPerWindow, nChans) :		if not numChannelsPerWindow == None:			nChansPerWindow = int(numChannelsPerWindow)			if nChansPerWindow > nChans:				nChansPerWindow = nChans		# This can be edited if need be to conform to a user's parameter entries		nChansToPlot = nChans		chanWindows = self.create_windows(0, nChans, nChansToPlot, nChansPerWindow)		return chanWindows, nChansToPlot	def create_samples_windows(self, rangesOfDataToPlot, maxLengthOfWindow, nSamples) :		# print("rangesOfDataToPlot: ", rangesOfDataToPlot, " maxLengthOfWindow: ", maxLengthOfWindow, " nSamples: ", nSamples)		nSamplesToPlot = 0		sampWins = []		if rangesOfDataToPlot[0][0] == None:			rangesOfDataToPlot = [[0, nSamples]]			# print("New ranges of data to plot: ", rangesOfDataToPlot)		for rngOfDataToPlot in rangesOfDataToPlot :			rangeOfDataToPlot = get_indices_range_of_data( rngOfDataToPlot, (0, nSamples), self.sampleRate )			nSamplesToPlot += rangeOfDataToPlot[1] - rangeOfDataToPlot[0]			if maxLengthOfWindow == None or maxLengthOfWindow == "" :				samplesPerWindow = nSamplesToPlot			else :				samplesPerWindow = get_sample_value(maxLengthOfWindow, rangeOfDataToPlot, self.sampleRate)			# print("rngOfDataToPlot: ", rngOfDataToPlot, "rangeOfDataToPlot: ", rangeOfDataToPlot, " nSamplesToPlot: ", nSamplesToPlot, " samplesPerWindow: ", samplesPerWindow )			sampWins.append(self.create_windows(rangeOfDataToPlot[0], rangeOfDataToPlot[1], nSamplesToPlot, samplesPerWindow))		# print("sampWins: ", sampWins)		return sampWins[0]	def create_windows(self, startRange, endRange, nItems, nItemsPerWindow) :		nWindows = int(math.ceil(nItems / nItemsPerWindow))		# print("nWindows: ", nWindows)		windows = []		windowEnd = startRange		nItemsAdded = 0		for windowI in range(0, nWindows):			nItemsAdded += nItemsPerWindow			windowStart = windowEnd			windowEnd = int(math.floor( windowEnd + nItemsPerWindow ))			if nItemsAdded > nItems:				windowEnd = endRange			windows.append([windowStart, windowEnd])		return windows	def streamline_params(self, inParams):		if "SAMPLES_PROCESSING" in inParams.keys():			del inParams['SAMPLES_PROCESSING']		if "PER_CHANNEL" in inParams.keys():			del inParams['PER_CHANNEL']				if "CHAN_RANGE" in inParams.keys():			del inParams['CHAN_RANGE']			return inParams